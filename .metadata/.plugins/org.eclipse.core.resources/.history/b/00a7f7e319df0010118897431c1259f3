package com.example.event.service;

import com.example.event.dto.response.EventSummaryResponse;
import com.example.event.model.Event; // Required for entity association
import com.example.event.model.EventFavorite;
import com.example.event.model.EventFavoriteId;
import com.example.event.model.User; // Required for entity association
import com.example.event.repository.EventFavoriteRepository;
import com.example.event.repository.EventRepository; // Needed for event/user lookup
import com.example.event.repository.EventSummaryProjection;
import com.example.event.repository.UserRepository; // Needed for user lookup
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.event.exception.ResourceNotFoundException;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class EventFavoriteService {

    private final EventFavoriteRepository favoriteRepository;
    private final EventRepository eventRepository; // Needed to check event existence
    private final UserRepository userRepository;   // Needed to check user existence

    // Manual Constructor
    public EventFavoriteService(
            EventFavoriteRepository favoriteRepository,
            EventRepository eventRepository,
            UserRepository userRepository) {
        this.favoriteRepository = favoriteRepository;
        this.eventRepository = eventRepository;
        this.userRepository = userRepository;
    }

    /**
     * Retrieves the list of events favorited by a specific user.
     */
    public List<EventSummaryResponse> getFavoritesByUserId(Long userId) {
        // NOTE: We assume the user exists, or let the repository throw an error if no favorites are found.

        List<EventSummaryProjection> projections = 
            favoriteRepository.findFavoriteEventsSummaryByUserId(userId);
        
        return projections.stream()
            .map(p -> new EventSummaryResponse(
                p.getId(),
                p.getTitle(),
                p.getStartDatetime(),
                p.getLocationCity(),
                p.getMainImageUrl(),
                p.getPrice()
            ))
            .collect(Collectors.toList());
    }

    /**
     * Adds an event to the specified user's favorites list.
     */
    @Transactional
    public boolean addFavorite(Long userId, Long eventId) { // CHANGED: Returns boolean
        // 1. Validation and Check for existence...
        
        // NOTE: Keep the loaded entities (user, event) in variables for use below.
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + userId));
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> new ResourceNotFoundException("Event not found with ID: " + eventId));
        
        Optional<EventFavorite> existingFavorite = favoriteRepository.findById_UserIdAndId_EventId(userId, eventId);

        if (existingFavorite.isEmpty()) {
            // ... (creation logic remains the same)
            EventFavoriteId id = new EventFavoriteId(userId, eventId);
            
            // FIX: Pass the loaded 'user' and 'event' entities instead of their IDs
            EventFavorite favorite = new EventFavorite(
                id,                           // 1. EventFavoriteId id
                user,                         // 2. User entity (REQUIRED)
                event,                        // 3. Event entity (REQUIRED)
                OffsetDateTime.now()          // 4. OffsetDateTime createdAt
            );
            
            favoriteRepository.save(favorite);
            
            return true; // NEW: Successfully created
        }
        
        return false; // NEW: Already existed
    }
        // If it exists, we do nothing (POST is idempotent)
   

    /**
     * Removes an event from the specified user's favorites list.
     */
    @Transactional
    public void removeFavorite(Long userId, Long eventId) {
        // NOTE: We rely on the repository's delete method to handle the composite key lookup.
        // It's acceptable if the record doesn't exist (no exception needed for DELETE).
        favoriteRepository.deleteById_UserIdAndId_EventId(userId, eventId);
    }
}